#include <stdio.h>

int main(void) {
    // 비트 연산자
    // 1바이트 = 8비트, 8칸이 결과로 나옴
    
    // MSB: 제일 왼쪽을 부호 비트로 사용

    // 과거의 방식(단순히 MSB만 1로 바꿔 음수 표현)
    // +5 = 00000101, -5 = 10000101
    // 문제점
    // 1. 0이 두개 존재 +0, -0
    // 2. 복잡한 계산 회로: 덧셈 회로와 뺄셈 회로를 따로 만들어야함

    // 해결책: '2의 보수'
    // +13: 00001101, 1의 보수(비트 반전): 1110010, 2의 보수(+1, 부호비트 1): 11110011
    // -13: 11110011
    // 둘을 더하면 100000000이 나오지만 비트는 8개, 제일 왼쪽 1이 제외되면서 0이 된다.

    // ^ (XOR) -> 같으면 0, 다르면 1

    int a = 13, b = 10;
    int result = a ^ b;

    // printf("result: %d\n", result);

    printf("~a: %d\n", ~a); // 결과: -14
    // -14가 나오는 이유
    // +13 NOT 연산 결과: 11110010 (부호 1 = 음수, 나머지로 2의 보수를 통해 숫자 찾음.)
    // 1의 보수: 0001101, 2의 보수: 0001110: 14
    // 따라서 -14

    // 시프트(Shift) 연산자
    // << (왼쪽 시프트) - 1칸에 2배씩 커짐
    int num = 13; // 00001101
    printf("num << 1 = %d\n", num << 1); // 결과: 26

    // >> (오른쪽 시프트) - 1칸에 2배씩 작아짐
    // c언어에서 정수/정수 = 정수, 나머지는 버려짐
    printf("num << 1 = %d\n", num >> 1); // 결과: 6


    return 0;
}